//! Common traits and types for Magic DOM structs.

use conversions::{ConversionResult, FromJSValConvertible, ToJSValConvertible};
use jsapi;
use jsval;

use std::marker::PhantomData;
use std::mem;
use std::ptr;

/// the proper name is the name of the struct generated by the MagicDom macro
#[macro_export]
macro_rules! magic_dom {
    (   $proper_name:ident,
        struct $name:ident {
            $(
                $field:ident : $field_ty:ty,
            )*
        }
    ) => {
        mod magic_dom_spec {
            #[allow(dead_code)]
            #[derive(MagicDom)]
            struct $name {
                $(
                    $field : $field_ty,
                )*
            }
        }
        pub use magic_dom_spec::$proper_name as $proper_name;
    }
}

#[macro_export]
macro_rules! get_js_val_number {
    ($val:ident, $cx:ident, $call_args:ident, $arg_idx:expr) => {
        let $val = match ToNumber($cx, $call_args.index($arg_idx)) {
            Ok(num) => num,
            Err(_) => {
                let error_str = CString::new(format!("Can't recognize arg {}", $arg_idx).into_bytes());
                JS_ReportErrorASCII($cx, error_str.as_ptr() as *const libc::c_char);
                return false;
            },
        };
    }
}

#[macro_export]
macro_rules! js_getter {
    ($name:ident, $js_getter_name:ident, $getter_name:ident, $js_value_method:ident) => {
        pub extern "C" fn $js_getter_name (cx: *mut jsapi::JSContext, argc: u32, vp: *const JS::Value)
                                           -> bool {
            let call_args = CreateCallArgsFromVp(argc, vp);
            if call_args._base.argc_ != 0 {
                JS_ReportErrorASCII(cx, b"getter doesn't require any arguments\0".as_ptr()
                                    as *const libc::c_char);
                return false;
            }
            let obj = match check_this(cx, call_args) {
                Some(jsobj) => {
                    match $name :: from_object(jsobj) {
                        Some(obj_) => obj_,
                        None => {
                            JS_ReportErrorASCII(cx, b"Can't convert JSObject\0".as_ptr()
                                                as *const libc::c_char);
                            return false;
                        },
                    }
                },
                None => {
                    JS_ReportErrorASCII(cx, b"Can't find JS Object\0".as_ptr()
                                        as *const libc::c_char);
                    return false;
                }
            };
            let val = $getter_name(obj, cx);
            call_args.rval.set($js_value_method(val));
            true
        }
    }
}

#[macro_export]
macro_rules! js_setter {
    ($name:ident, $js_setter_name:ident, $setter_name:ident) => {
        pub extern "C" fn $js_setter_name (cx: *mut jsapi::JSContext, argc: u32, vp: *const JS::Value)
                                           -> bool {
            let call_args = CreateCallArgsFromVp(argc, vp);
            if call_args._base.argc_ != 1 {
                JS_ReportErrorASCII(cx, b"setter requires exactly 1 arguments\0".as_ptr()
                                    as *const libc::c_char);
                return false;
            }
            let obj = match check_this(cx, call_args) {
                Some(jsobj) => {
                    match $name :: from_object(jsobj) {
                        Some(obj_) => obj_,
                        None => {
                            JS_ReportErrorASCII(cx, b"Can't convert JSObject\0".as_ptr()
                                                as *const libc::c_char);
                            return false;
                        },
                    }
                },
                None => {
                    JS_ReportErrorASCII(cx, b"Can't find JS Object\0".as_ptr()
                                        as *const libc::c_char);
                    return false;
                }
            };
            let v = match ToNumber(cx, call_args.index(0)) {
                Ok(num) => num,
                Err(_) => {
                    JS_ReportErrorASCII(cx, b"Can't recognize arg 0\0".as_ptr() as *const libc::c_char);
                    return false;
                },
            };
            #setter_name(obj, cx, v);
            true
        }
    }
}

/// TODO FITZGEN
pub trait SlotIndex {
    fn slot_index() -> u32;
}

/// TODO FITZGEN
pub struct MagicSlot<T, I> {
    slot_type: PhantomData<T>,
    slot_index: PhantomData<I>,
}

impl<T, I> MagicSlot<T, I> {
    /// Construct a new `MagicSlot`.
    pub fn new() -> MagicSlot<T, I> {
        MagicSlot {
            slot_type: PhantomData,
            slot_index: PhantomData,
        }
    }
}

impl<T, I> MagicSlot<T, I>
    where T: ToJSValConvertible + FromJSValConvertible<Config = ()>,
          I: SlotIndex
{
    unsafe fn get_object(&self) -> *mut jsapi::JSObject {
        let obj_ptr_ptr: *const *mut jsapi::JSObject = mem::transmute(self);
        debug_assert!(obj_ptr_ptr != ptr::null());
        /// subtract a word according to current struct memory layout
        let obj_ptr = (*obj_ptr_ptr as usize -
                       mem::size_of::<usize>()) as *mut jsapi::JSObject;
        obj_ptr
    }

    /// Get the value stored in this slot.
    ///
    /// # Unsafety
    ///
    /// Requires that this `MagicSlot`'s self ptr is the same as the containing
    /// magic DOM struct's pointer to the `JSObject` that has the appropriate
    /// slots.
    pub unsafe fn get(&self, cx: *mut jsapi::JSContext) -> T {
        let obj = self.get_object();
        rooted!(in(cx) let val = jsapi::JS_GetReservedSlot(obj, I::slot_index()));

        let conversion = FromJSValConvertible::from_jsval(cx, val.handle(), ())
            .expect("Should never put anything into a MagicSlot that we can't \
                     convert back out again");

        match conversion {
            ConversionResult::Success(v) => v,
            ConversionResult::Failure(why) => {
                panic!("Should never put anything into a MagicSlot that we \
                        can't convert back out again: {}",
                       why);
            }
        }
    }

    /// Store a value into this slot
    ///
    /// # Unsafety
    ///
    /// The same pitfalls as `get`.
    pub unsafe fn set(&self, cx: *mut jsapi::JSContext, t: T) {
        rooted!(in(cx) let obj = self.get_object());
        // TODO: read + drop old slot value.

        rooted!(in(cx) let mut val = jsval::UndefinedValue());
        t.to_jsval(cx, val.handle_mut());
        jsapi::JS_SetReservedSlot(obj.get(), I::slot_index(), &*val);
    }

    /// TODO FITZGEN
    pub unsafe fn initialize(&self, cx: *mut jsapi::JSContext, t: T) {
        // TODO: same as `set` but assert that the slot is `undefined` and don't
        // read + drop the slot value.
        rooted!(in(cx) let obj = self.get_object());

        rooted!(in(cx) let mut val = jsval::UndefinedValue());
        t.to_jsval(cx, val.handle_mut());
        jsapi::JS_SetReservedSlot(obj.get(), I::slot_index(), &*val);
    }
}
